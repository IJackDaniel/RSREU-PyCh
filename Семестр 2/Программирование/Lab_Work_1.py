from random import uniform
from time import perf_counter_ns


# Ввод n - длины массива; choice - выбор заполнения массива
n = int(input("Введите длину массива: "))
choice = int(input("Выберите формат ввода массива:\n 1 - автоматический ввод\n 2 - ручной ввод\n"))
# Объявление массива
arr = [0] * n

# Выбор метода заполнения массива
match choice:
    case 1:
        # Автоматическое заполнение вещественными числами от 1 до 100 с округлением до 2 знаков после запятой
        for c1 in range(0, n, 1):
            arr[c1] = round(uniform(1, 100), 2)
    case 2:
        # Заполнение массива вручную с клавиатуры
        for c2 in range(0, n, 1):
            arr[c2] = float(input(f"Ввод элемента {c2}: "))
    case _:
        # Вывод ошибки при выборе заполнения массива
        print("Неправильно выбран формат заполнения массива")
        exit(1)


# Эхо-вывод исходного массива
print(f"Исходный массив: {arr}")

# Решение задачи без использования методов списков
# Начало отсчёта времени обработки массива
t0 = perf_counter_ns()
for rep1 in range(1000):

    lst1 = arr.copy()

    # Нахождение первого наибольшего элемента в массиве и его индекса
    m1 = -1e10000
    for i in range(0, n, 1):
        if lst1[i] > m1:
            m1 = lst1[i]
            i1 = i

    # Нахождение второго наибольшего элемента в массиве и его индекса
    m2 = -1e10000
    for j in range(0, n, 1):
        if lst1[j] > m2 and j != i1:
            m2 = lst1[j]
            i2 = j

    # Упорядочиваем индексы
    if i1 > i2:
        i1, i2 = i2, i1

    # Обнуление всех элементов, которые находятся между двумя наибольшими
    for k in range(0, n, 1):
        if i1 < k < i2:
            lst1[k] = 0

# Конец отсчёта времени обработки массива
t1 = perf_counter_ns()
# Подсчёт времени обработки
T1 = round(((t1-t0)/1000)/1e6, 7)

# Решение задачи с использованием методов списков
# Начало отсчёта времени обработки массива
t2 = perf_counter_ns()
for rep2 in range(1000):

    lst2 = arr.copy()

    # Нахождение первого наибольшего элемента в массиве и его индекса
    m3 = max(lst2)
    i3 = lst2.index(m3)

    # Нахождение второго наибольшего элемента в массиве и его индекса
    lst3 = lst2.copy()
    lst3[i3] = -1e1000
    i4 = lst3.index((max(lst3)))

    # Упорядочиваем индексы
    if i3 > i4:
        i3, i4 = i4, i3

    # Обнуление всех элементов, которые находятся между двумя наибольшими
    for k in range(0, n, 1):
        if i3 < k < i4:
            lst2[k] = 0

# Конец отсчёта времени обработки массива
t3 = perf_counter_ns()
# Подсчёт времени обработки
T2 = round(((t3 - t2) / 1000) / 1e6, 7)

# Вывод двух массивов для сравнения результатов
print("\nМассив A обработан без использования методов списков, а массив B с использованием методов.")
print(f"Массив A: {lst1}")
print(f"Массив B: {lst2}")
print()
# Вывод времени выполнения каждого из решений
print(f"Время выполнения для массива A = {T1} мс")
print(f"Время выполнения для массива B = {T2} мс")
# Сравнение времени
if T1 > T2:
    print(f"Программа с использованием методов списков оказалась на {round((T1 - T2), 7)} мс быстрее")
elif T2 > T1:
    print(f"Программа без использования методов списков оказалась на {round((T2 - T1), 7)} мс быстрее")
else:
    print("Время выполнения двух программ примерно равно")
